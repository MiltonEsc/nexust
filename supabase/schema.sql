


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";





SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."companies" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "owner_id" "uuid" NOT NULL
);


ALTER TABLE "public"."companies" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_company_and_add_owner"("company_name" "text") RETURNS "public"."companies"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  new_company companies;
BEGIN
  -- Inserta la nueva empresa y guarda la fila creada en la variable 'new_company'.
  INSERT INTO public.companies (name, owner_id)
  VALUES (company_name, auth.uid())
  RETURNING * INTO new_company;

  -- Crea el vínculo entre el usuario (dueño) y la nueva empresa.
  INSERT INTO public.company_users (company_id, user_id, role, status)
  VALUES (new_company.id, auth.uid(), 'owner', 'accepted');

  -- Devuelve la información completa de la nueva empresa a la aplicación.
  RETURN new_company;
END;
$$;


ALTER FUNCTION "public"."create_company_and_add_owner"("company_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_company_members"("p_company_id" "uuid") RETURNS TABLE("email" "text", "role" "text", "status" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Comprobación de seguridad: ¿El usuario actual es miembro de la empresa?
  IF NOT EXISTS (
    SELECT 1
    FROM public.company_users cu
    WHERE cu.company_id = p_company_id
      AND cu.user_id = auth.uid()
      AND cu.status = 'accepted'
  ) THEN
    RETURN;
  END IF;

  -- Consulta principal con la corrección
  RETURN QUERY
  SELECT
    u.email::text,  -- <--- ¡ESTA ES LA CORRECCIÓN! Convertimos el email a tipo 'text'.
    cu.role,
    cu.status
  FROM
    public.company_users AS cu
  JOIN
    auth.users AS u ON cu.user_id = u.id
  WHERE
    cu.company_id = p_company_id;
END;
$$;


ALTER FUNCTION "public"."get_company_members"("p_company_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_my_companies"() RETURNS SETOF "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- This query can be executed because the function is a SECURITY DEFINER
  RETURN QUERY SELECT company_id FROM public.company_users WHERE user_id = auth.uid();
END;
$$;


ALTER FUNCTION "public"."get_my_companies"() OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_users" (
    "company_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'member'::"text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL
);


ALTER TABLE "public"."company_users" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."equipos" (
    "id" bigint NOT NULL,
    "marca" "text",
    "modelo" "text",
    "numero_serie" "text",
    "estado" "text",
    "ubicacion" "text",
    "proveedor_id" bigint,
    "numero_factura" "text",
    "fecha_compra" "date",
    "fecha_vencimiento_garantia" "date",
    "imagen" "text",
    "trazabilidad" "jsonb" DEFAULT '[]'::"jsonb",
    "factura_pdf_url" "text",
    "costo" numeric,
    "company_id" "uuid"
);


ALTER TABLE "public"."equipos" OWNER TO "postgres";


ALTER TABLE "public"."equipos" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."equipos_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."perifericos" (
    "id" bigint NOT NULL,
    "tipo" "text",
    "marca" "text",
    "modelo" "text",
    "numero_serie" "text",
    "estado" "text",
    "proveedor_id" bigint,
    "numero_factura" "text",
    "fecha_compra" "date",
    "fecha_vencimiento_garantia" "date",
    "imagen" "text",
    "trazabilidad" "jsonb" DEFAULT '[]'::"jsonb",
    "costo" numeric,
    "company_id" "uuid"
);


ALTER TABLE "public"."perifericos" OWNER TO "postgres";


ALTER TABLE "public"."perifericos" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."perifericos_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."proveedores" (
    "id" bigint NOT NULL,
    "nombre" "text" NOT NULL,
    "contacto" "text",
    "telefono" "text",
    "email" "text",
    "company_id" "uuid"
);


ALTER TABLE "public"."proveedores" OWNER TO "postgres";


ALTER TABLE "public"."proveedores" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."proveedores_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."registros" (
    "id" bigint NOT NULL,
    "nombre" "text" NOT NULL,
    "cargo" "text",
    "cedula" "text",
    "fecha_ingreso" "date",
    "equipo_id" bigint,
    "software_ids" bigint[],
    "perifericos_ids" bigint[],
    "trazabilidad" "jsonb" DEFAULT '[]'::"jsonb",
    "company_id" "uuid",
    "departamento" "text",
    "cuentas_creadas" "text",
    "induccion_tic" boolean
);


ALTER TABLE "public"."registros" OWNER TO "postgres";


ALTER TABLE "public"."registros" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."registros_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."software" (
    "id" bigint NOT NULL,
    "nombre" "text",
    "tipo" "text",
    "version" "text",
    "stock" integer,
    "proveedor_id" bigint,
    "numero_factura" "text",
    "fecha_compra" "date",
    "fecha_vencimiento" "date",
    "imagen" "text",
    "trazabilidad" "jsonb" DEFAULT '[]'::"jsonb",
    "costo" numeric,
    "company_id" "uuid"
);


ALTER TABLE "public"."software" OWNER TO "postgres";


ALTER TABLE "public"."software" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."software_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."company_users"
    ADD CONSTRAINT "company_users_pkey" PRIMARY KEY ("company_id", "user_id");



ALTER TABLE ONLY "public"."equipos"
    ADD CONSTRAINT "equipos_numeroserie_key" UNIQUE ("numero_serie");



ALTER TABLE ONLY "public"."equipos"
    ADD CONSTRAINT "equipos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."perifericos"
    ADD CONSTRAINT "perifericos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."proveedores"
    ADD CONSTRAINT "proveedores_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."registros"
    ADD CONSTRAINT "registros_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."software"
    ADD CONSTRAINT "software_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."company_users"
    ADD CONSTRAINT "company_users_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."company_users"
    ADD CONSTRAINT "company_users_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."equipos"
    ADD CONSTRAINT "equipos_proveedor_id_fkey" FOREIGN KEY ("proveedor_id") REFERENCES "public"."proveedores"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."perifericos"
    ADD CONSTRAINT "perifericos_proveedorid_fkey" FOREIGN KEY ("proveedor_id") REFERENCES "public"."proveedores"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."registros"
    ADD CONSTRAINT "registros_equipoid_fkey" FOREIGN KEY ("equipo_id") REFERENCES "public"."equipos"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."software"
    ADD CONSTRAINT "software_proveedor_id_fkey" FOREIGN KEY ("proveedor_id") REFERENCES "public"."proveedores"("id") ON DELETE SET NULL;



CREATE POLICY "Dueño puede ver sus empresas" ON "public"."companies" FOR SELECT USING (("owner_id" = "auth"."uid"()));



CREATE POLICY "Los dueños de empresas pueden añadir miembros." ON "public"."company_users" FOR INSERT WITH CHECK (("company_id" IN ( SELECT "companies"."id"
   FROM "public"."companies"
  WHERE ("companies"."owner_id" = "auth"."uid"()))));



CREATE POLICY "Los dueños pueden actualizar sus empresas." ON "public"."companies" FOR UPDATE USING (("owner_id" = "auth"."uid"()));



CREATE POLICY "Los miembros pueden gestionar el software de sus empresas." ON "public"."software" USING (("company_id" IN ( SELECT "public"."get_my_companies"() AS "get_my_companies")));



CREATE POLICY "Los miembros pueden gestionar los activos de sus empresas." ON "public"."equipos" USING (("company_id" IN ( SELECT "public"."get_my_companies"() AS "get_my_companies")));



CREATE POLICY "Los miembros pueden gestionar los periféricos de sus empresas." ON "public"."perifericos" USING (("company_id" IN ( SELECT "public"."get_my_companies"() AS "get_my_companies")));



CREATE POLICY "Los miembros pueden gestionar los proveedores de sus empresas." ON "public"."proveedores" USING (("company_id" IN ( SELECT "public"."get_my_companies"() AS "get_my_companies")));



CREATE POLICY "Los miembros pueden gestionar los registros de usuario de sus e" ON "public"."registros" USING (("company_id" IN ( SELECT "public"."get_my_companies"() AS "get_my_companies")));



CREATE POLICY "Los miembros pueden ver a otros miembros de sus empresas." ON "public"."company_users" FOR SELECT USING (("company_id" IN ( SELECT "public"."get_my_companies"() AS "get_my_companies")));



CREATE POLICY "Los usuarios autenticados pueden crear empresas." ON "public"."companies" FOR INSERT WITH CHECK (("auth"."uid"() = "owner_id"));



CREATE POLICY "Los usuarios pueden crear empresas." ON "public"."companies" FOR INSERT WITH CHECK (("auth"."uid"() = "owner_id"));



CREATE POLICY "Los usuarios pueden ver las empresas de las que son miembros." ON "public"."companies" FOR SELECT USING (("id" IN ( SELECT "company_users"."company_id"
   FROM "public"."company_users"
  WHERE ("company_users"."user_id" = "auth"."uid"()))));



CREATE POLICY "Owners can invite users to their own companies" ON "public"."company_users" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."companies"
  WHERE (("companies"."id" = "company_users"."company_id") AND ("companies"."owner_id" = "auth"."uid"())))));



CREATE POLICY "Solo dueño puede ver sus empresas" ON "public"."companies" FOR SELECT USING (("owner_id" = "auth"."uid"()));



CREATE POLICY "Users can accept their own pending invitations" ON "public"."company_users" FOR UPDATE USING ((("auth"."uid"() = "user_id") AND ("status" = 'pending'::"text"))) WITH CHECK (("status" = 'accepted'::"text"));



CREATE POLICY "Users can decline (delete) their own pending invitations" ON "public"."company_users" FOR DELETE USING ((("auth"."uid"() = "user_id") AND ("status" = 'pending'::"text")));



CREATE POLICY "Users can see their own membership status" ON "public"."company_users" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view companies they are a member of" ON "public"."companies" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."company_users" "cu"
  WHERE (("cu"."company_id" = "companies"."id") AND ("cu"."user_id" = "auth"."uid"()) AND ("cu"."status" = 'accepted'::"text")))));



CREATE POLICY "Usuario logueado puede crear empresa" ON "public"."companies" FOR INSERT WITH CHECK (("owner_id" = "auth"."uid"()));



CREATE POLICY "Usuario puede agregarse a una empresa" ON "public"."company_users" FOR INSERT WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "Usuario puede ver su pertenencia" ON "public"."company_users" FOR SELECT USING (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."companies" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_users" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."equipos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."perifericos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."proveedores" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."registros" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."software" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

























































































































































GRANT ALL ON TABLE "public"."companies" TO "anon";
GRANT ALL ON TABLE "public"."companies" TO "authenticated";
GRANT ALL ON TABLE "public"."companies" TO "service_role";



GRANT ALL ON FUNCTION "public"."create_company_and_add_owner"("company_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_company_and_add_owner"("company_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_company_and_add_owner"("company_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_company_members"("p_company_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_company_members"("p_company_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_company_members"("p_company_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_my_companies"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_my_companies"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_my_companies"() TO "service_role";


















GRANT ALL ON TABLE "public"."company_users" TO "anon";
GRANT ALL ON TABLE "public"."company_users" TO "authenticated";
GRANT ALL ON TABLE "public"."company_users" TO "service_role";



GRANT ALL ON TABLE "public"."equipos" TO "anon";
GRANT ALL ON TABLE "public"."equipos" TO "authenticated";
GRANT ALL ON TABLE "public"."equipos" TO "service_role";



GRANT ALL ON SEQUENCE "public"."equipos_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."equipos_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."equipos_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."perifericos" TO "anon";
GRANT ALL ON TABLE "public"."perifericos" TO "authenticated";
GRANT ALL ON TABLE "public"."perifericos" TO "service_role";



GRANT ALL ON SEQUENCE "public"."perifericos_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."perifericos_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."perifericos_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."proveedores" TO "anon";
GRANT ALL ON TABLE "public"."proveedores" TO "authenticated";
GRANT ALL ON TABLE "public"."proveedores" TO "service_role";



GRANT ALL ON SEQUENCE "public"."proveedores_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."proveedores_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."proveedores_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."registros" TO "anon";
GRANT ALL ON TABLE "public"."registros" TO "authenticated";
GRANT ALL ON TABLE "public"."registros" TO "service_role";



GRANT ALL ON SEQUENCE "public"."registros_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."registros_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."registros_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."software" TO "anon";
GRANT ALL ON TABLE "public"."software" TO "authenticated";
GRANT ALL ON TABLE "public"."software" TO "service_role";



GRANT ALL ON SEQUENCE "public"."software_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."software_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."software_id_seq" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";






























-- Maintenance schedules for preventive maintenance planning
CREATE TABLE IF NOT EXISTS "public"."maintenance_schedules" (
    "id" bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    "company_id" uuid NOT NULL,
    "equipo_id" bigint NULL,
    "title" text NOT NULL,
    "periodicity" text DEFAULT 'custom'::text NOT NULL, -- daily, weekly, monthly, quarterly, semiannual, annual, custom
    "frequency_days" integer DEFAULT 0 NOT NULL,         -- used when periodicity = custom
    "next_date" date NOT NULL,
    "responsible" text,
    "notes" text,
    "active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL
);

ALTER TABLE "public"."maintenance_schedules" OWNER TO "postgres";

ALTER TABLE ONLY "public"."maintenance_schedules"
  ADD CONSTRAINT "maintenance_schedules_company_id_fkey"
  FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."maintenance_schedules"
  ADD CONSTRAINT "maintenance_schedules_equipo_id_fkey"
  FOREIGN KEY ("equipo_id") REFERENCES "public"."equipos"("id") ON DELETE SET NULL;

-- RLS
ALTER TABLE "public"."maintenance_schedules" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Miembros gestionan planes de mantenimiento de sus empresas" ON "public"."maintenance_schedules"
  USING (("company_id" IN (SELECT "public"."get_my_companies"())))
  WITH CHECK (("company_id" IN (SELECT "public"."get_my_companies"())));

-- Grants (align with other tables)
GRANT ALL ON TABLE "public"."maintenance_schedules" TO "anon";
GRANT ALL ON TABLE "public"."maintenance_schedules" TO "authenticated";
GRANT ALL ON TABLE "public"."maintenance_schedules" TO "service_role";

RESET ALL;
